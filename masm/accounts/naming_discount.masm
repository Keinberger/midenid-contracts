use.miden::active_account
use.miden::native_account
use.miden::account_id
use.miden::input_note
use.miden::output_note
use.miden::active_note
use.miden::tx

## Storage Slots
const.INIT_FLAG_SLOT=0
const.OWNER_SLOT=1
const.PRICES_SLOT=2 # domain prices map([0, letter_count, payment_token_prefix, payment_token_suffix] -> [PRICE])
const.ACCOUNT_ID_TO_DOMAIN_SLOT=3
const.DOMAIN_TO_ACCOUNT_ID_SLOT=4
const.DOMAIN_TO_OWNER_SLOT=5
const.REF_RATE_SLOT=6
const.REF_TOTAL_REVENUE_SLOT=7
const.REF_CLAIMED_REVENUE_SLOT=8
const.DOMAIN_COUNT_SLOT=9
const.TOTAL_REVENUE_SLOT=10 # protocol total revenue map([0, 0, token_prefix, token_suffix] -> amount)
const.CLAIMED_REVENUE_SLOT=11
const.DOMAIN_EXPIRY_DATES=12 # domain expiry dates map(DOMAIN -> expiry timestamp)
const.ONE_YEAR_TIMESTAMP_SLOT=13

## Errors
const.ERR_ONLY_OWNER="Only owner"
const.ERR_ONLY_DOMAIN_OWNER="Only domain owner"
const.ERR_ALREADY_INITIALIZED="Contract already initialized"
const.ERR_PAYMENT_TOKEN_NOT_ALLOWED="This payment token not allowed"
const.ERR_PRICE_ZERO="Price zero for this length"
const.ERR_VALIDATE_PAYMENT_SUB_OVERFLOW="Validating payment sub overflow"
const.ERR_INSUFFICIENT_AMOUNT_PAID="Paid amount less than price"
const.ERR_DOMAIN_NOT_AVAILABLE="Domain is already taken"
const.ERR_DOMAIN_LENGTH_TOO_HIGH="21 characters allowed"
const.ERR_REF_RATE_OVERLIMIT="Ref rate higher or equal to 10000"
const.ERR_REF_RATE_TOO_HIGH="Max 2500 ref rate"
const.ERR_REF_RATE_ZERO="Ref rate zero"
const.ERR_REF_NOT_EXIST="Referrer rate is zero"
const.DOMAIN_LENGTH_TOO_HIGH="Maximum 21 characters allowed"
const.ERR_INVALID_DOMAIN_LENGTH="Domain length field does not match actual character count"
const.ERR_EMPTY_DOMAIN="Domain length zero"
const.ERR_CALCULATE_DISCOUNT_OVERFLOW="Overflow at discount calc"
const.ERR_CALCULATE_DISCOUNT_UNDERFLOW="Underflow at discount calc"
const.ERR_DOMAIN_REGISTRATION_LENGTH_TOO_HIGH="Max 10 years"
const.ERR_OVERFLOW_AT_DOMAIN_TIMESTAMP_LENGTH="Timestamp len overflow"
const.ERR_DOMAIN_NOT_EXPIRED="Domain not expired"
const.ERR_U32_OVERFLOW="U32 Overflow"
const.ERR_DOMAIN_EXPIRED="Domain expired"
const.ERR_UNDERFLOW_AT_FEE_CALC="Fee calculation underflow"
const.ERR_OVERFLOW_AT_FEE_CALC="Fee calculation overflow"

## Memory Pointers

const.MEM_DOMAIN=0x0020 # WORD
const.MEM_PAYMENT_TOKEN=0x0024 # WORD
const.MEM_REFERRER=0x0028 # WORD
const.MEM_DOMAIN_NEW_OWNER=0x002C # WORD
const.MEM_REG_LEN=0x0030 # WORD
const.MEM_RECIPIENT=0x0034 # WORD
const.MEM_NOTE_DETAILS=0x0038 # WORD
const.MEM_REF_RATE=0x003C # WORD
const.MEM_TOTAL_PAID_AMT=0x0050 # felt
const.MEM_PROTOCOL_FEE_AMT=0x0051 # felt
const.MEM_REFERRER_FEE_AMT=0x0052 # felt

## Constants
#const.YEAR=31536000 # In seconds
const.MAX_REG_LEN=10 # Years
const.MAX_NAME_LENGTH=21
const.FIVE_YR_DISCOUNT=5000 # 50%
const.THREE_YR_DISCOUNT=3000 # 30%
const.MAX_REF_RATE=10000 # Basis point
const.REF_RATE_LIMIT=2500 # %25
const.DOMAIN_LETTER_PRICE_BREAKPOINT=5 # After 5 letters constant price

const.MAX_FELT_PART=0xFFFFFFFFFFFFFF # 8*7 bits

const.PAD_4TH_CHAR=16777216
const.PAD_3RD_CHAR=65536
const.PAD_2ND_CHAR=256
const.PAD_1ST_CHAR=1

# Input: [PAYMENT_TOKEN, DOMAIN, REG_LEN]
# Output: []
export.register
    mem_storew_be.MEM_PAYMENT_TOKEN dropw
    mem_storew_be.MEM_DOMAIN dropw
    mem_storew_be.MEM_REG_LEN dropw
    # []
    exec._assert_domain_available
    exec._assert_domain_rules
    exec._assert_payment_token
    
    exec._calculate_domain_price
    # [price]
    exec._receive_payment
    # []
    # Update domain owner
    push.0 exec.input_note::get_sender
    exec._update_domain_owner
    # []
    # Update domain map
    # This feature removed. Domain must be activated after
    #exec.note::get_sender
    #exec._update_domain_map
    exec._clear_domain_mapping

    # Set domain len
    exec._update_domain_length

    exec._calculate_domain_price
    
    # [price]
    exec._increase_total_revenue

    # []
    exec._after_domain_register
end

# Input: [REFERRER, PAYMENT_TOKEN, DOMAIN, REG_LEN]
export.register_with_referrer
    mem_storew_be.MEM_REFERRER dropw
    mem_storew_be.MEM_PAYMENT_TOKEN dropw
    mem_storew_be.MEM_DOMAIN dropw
    mem_storew_be.MEM_REG_LEN dropw
    # []
    exec._assert_domain_available
    exec._assert_domain_rules
    exec._assert_payment_token

    exec._calculate_domain_price
    # [price]
    exec._receive_payment
    # []
    # Update domain owner
    push.0 exec.input_note::get_sender
    exec._update_domain_owner
    # []
    # Update domain map
    # This feature removed. Domain must be activated after
    #exec.note::get_sender
    #exec._update_domain_map
    exec._clear_domain_mapping

    # Set domain len
    exec._update_domain_length

    exec._calculate_domain_price
    # [price]
    exec._register_referrer_revenue
    # [protocol_revenue]
    exec._increase_total_revenue

    exec._after_domain_register
end

# Input: [DOMAIN]
# This function must be called to activate and match domain with account id
export.activate_domain
    mem_storew_be.MEM_DOMAIN dropw
    exec._assert_only_domain_owner

    push.0 exec.input_note::get_sender
    exec._update_domain_map
end

# Inputs: [NEW_OWNER, DOMAIN]
export.transfer
    mem_storew_be.MEM_DOMAIN_NEW_OWNER dropw
    mem_storew_be.MEM_DOMAIN dropw

    exec._assert_only_domain_owner
    exec._clear_domain_mapping

    padw mem_loadw_be.MEM_DOMAIN_NEW_OWNER drop drop
    # [NEW_OWNER]
    exec._update_domain_owner
    # []
end

# Input: [DOMAIN]
# Permissionless function that clears domain mapping for expired domains
export.clear_expired_domain
    mem_storew_be.MEM_DOMAIN
    # [DOMAIN]
    push.DOMAIN_EXPIRY_DATES
    exec.active_account::get_map_item drop drop drop
    # [expiry_time]
    exec.tx::get_block_timestamp
    # [current_time, expiry_time]
    lte assert.err=ERR_DOMAIN_NOT_EXPIRED
    # []
    exec._clear_domain_mapping
    # []
    push.0.0
    exec._update_domain_owner
    # []
    padw padw mem_loadw_be.MEM_DOMAIN
    # [DOMAIN, ZERO]
    push.DOMAIN_EXPIRY_DATES
    exec.native_account::set_map_item dropw dropw
    # []
end

# Input: [PAYMENT_TOKEN, DOMAIN, REG_LEN]
export.extend_domain
    mem_storew_be.MEM_PAYMENT_TOKEN dropw
    mem_storew_be.MEM_DOMAIN dropw
    mem_storew_be.MEM_REG_LEN dropw

    exec._assert_only_domain_owner
    exec._assert_payment_token
    exec._assert_domain_rules
    exec._assert_domain_not_expired

    exec._calculate_domain_price
    # [price]
    exec._receive_payment
    # []
    exec._extend_existing_domain_length
end

# Inputs: [TOKEN]
export.claim_referral_earnings
    nop
    # TODO
end

# Input: [OWNER, ONE_YEAR_TS]
export.init
    push.INIT_FLAG_SLOT exec.active_account::get_item drop drop drop
    assertz.err=ERR_ALREADY_INITIALIZED
    # [OWNER, ONE_YEAR_TS]
    push.OWNER_SLOT exec.native_account::set_item dropw
    # [ONE_YEAR_TS]
    push.1.0.0.0 push.INIT_FLAG_SLOT exec.native_account::set_item dropw
    # [ONE_YEAR_TS]
    push.ONE_YEAR_TIMESTAMP_SLOT exec.native_account::set_item dropw
end

# Input: [ASSET]
# Output: [pad(16)]
export.receive_asset
    exec.native_account::add_asset
    # => [ASSET', pad(12)]

    # drop the final asset
    dropw
    # => [pad(16)]
end

## Only owner methods

# Input: [NEW_OWNER]
# Output: []
export.update_registry_owner
    exec._assert_only_owner
    # [0, 0, new_owner_prefix, new_owner_suffix]
    push.OWNER_SLOT
    exec.native_account::set_item
    dropw
end

# Input: [0, letter_count, token_prefix, token_suffix, PRICE]
# Output: []
export.set_price
    exec._assert_only_owner
    push.PRICES_SLOT 
    exec.native_account::set_map_item dropw dropw
end

# Input: [REFERRER, RATE]
# Output: []
export.set_referrer_rate
    exec._assert_only_owner
    mem_storew_be.MEM_REFERRER dropw
    mem_storew_be.MEM_REF_RATE dropw

    padw mem_loadw_be.MEM_REF_RATE drop drop drop
    # [rate]
    push.REF_RATE_LIMIT
    # [limit, rate]
    lte assert.err=ERR_REF_RATE_TOO_HIGH
    # []
    padw mem_loadw_be.MEM_REF_RATE
    padw mem_loadw_be.MEM_REFERRER
    push.REF_RATE_SLOT exec.native_account::set_map_item dropw dropw
    # []
end

# Input: [TOKEN, NOTE_DETAILS, RECIPIENT]
export.claim_protocol_revenue
    mem_storew_be.MEM_PAYMENT_TOKEN dropw
    mem_storew_be.MEM_NOTE_DETAILS dropw
    mem_storew_be.MEM_RECIPIENT dropw
    exec._assert_only_owner
    # Create note


    padw mem_loadw_be.MEM_RECIPIENT
    padw mem_loadw_be.MEM_NOTE_DETAILS
    #padw mem_loadw_be.MEM_PAYMENT_TOKEN
    debug.stack.12
    # Stack must be
    # [tag, aux, note_type, exec_hint, RECIPIENT]
    exec.output_note::create # TODO
    debug.stack.8
    # Create ASSET word
    # []
    exec._get_remaining_revenue
    # [claimable_revenue]
    exec._get_asset
    # [ASSET]
end

# Input: [TOKEN]
export.withdraw_assets
    mem_storew_be.MEM_PAYMENT_TOKEN dropw
    exec._assert_only_owner
    nop
end

## Internal Methods

# Input: [] Memory: [REG_LEN, DOMAIN]
proc._extend_existing_domain_length
    padw mem_loadw_be.MEM_DOMAIN
    push.DOMAIN_EXPIRY_DATES exec.active_account::get_map_item drop drop drop
    # [current_len]
    padw mem_loadw_be.MEM_REG_LEN drop drop drop
    # [extend_len_as_year, current_len]
    exec._get_one_year
    u32assert2 u32overflowing_mul assertz.err=ERR_OVERFLOW_AT_DOMAIN_TIMESTAMP_LENGTH
    # [len * yr, current_len]
    u32assert2 u32overflowing_add assertz.err=ERR_OVERFLOW_AT_DOMAIN_TIMESTAMP_LENGTH
    # [new_len]
    push.0.0.0
    padw mem_loadw_be.MEM_DOMAIN
    push.DOMAIN_EXPIRY_DATES exec.native_account::set_map_item dropw dropw
    # []
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._clear_domain_mapping
    padw mem_loadw_be.MEM_DOMAIN
    # [DOMAIN]
    push.DOMAIN_TO_ACCOUNT_ID_SLOT exec.active_account::get_map_item
    # [ACCOUNT]
    padw swapw
    # [ACCOUNT, ZERO]
    push.ACCOUNT_ID_TO_DOMAIN_SLOT exec.native_account::set_map_item dropw dropw
    # []
    padw mem_loadw_be.MEM_DOMAIN
    # [DOMAIN]
    padw swapw
    # [DOMAIN, ZERO]
    push.DOMAIN_TO_ACCOUNT_ID_SLOT exec.native_account::set_map_item dropw dropw
    # []
end

# Input: [total_amt] Memory [PAYMENT_TOKEN, REFERRER]
# Output: [protocol_revenue]
proc._register_referrer_revenue
    
    mem_store.MEM_TOTAL_PAID_AMT
    mem_load.MEM_TOTAL_PAID_AMT
    # [total_amt]
    padw mem_loadw_be.MEM_REFERRER
    # [REFERRER, total_amt]
    push.REF_RATE_SLOT exec.active_account::get_map_item drop drop drop
    # [ref_rate, total_amt]
    dup gt.0 assert.err=ERR_REF_RATE_ZERO
    dup lt.MAX_REF_RATE assert.err=ERR_REF_RATE_OVERLIMIT
    # [ref_rate, total_amt]
    swap dup swap.2 swap
    # [total_amt, ref_rate, total_amt]
    u32assert2 u32overflowing_mul assertz.err=ERR_OVERFLOW_AT_FEE_CALC 
    u32assert2 u32div.10000
    # [(rate * total) / 10000, total_amt]
    sub 
    # [total - ((rate * total) / 10000)]
    # [protocol_revenue]
    mem_store.MEM_PROTOCOL_FEE_AMT
    mem_load.MEM_PROTOCOL_FEE_AMT
    mem_load.MEM_TOTAL_PAID_AMT swap
    # [protocol, total]
    u32assert2 u32overflowing_sub assertz.err=ERR_UNDERFLOW_AT_FEE_CALC
    mem_store.MEM_REFERRER_FEE_AMT
    # []
    ## Get current amt
    padw mem_loadw_be.MEM_REFERRER
    push.REF_TOTAL_REVENUE_SLOT exec.active_account::get_map_item drop drop drop
    # [current_amt]
    mem_load.MEM_REFERRER_FEE_AMT
    # [ref_revenue, current_amt]
    u32assert2 u32overflowing_add assertz.err=ERR_OVERFLOW_AT_FEE_CALC
    # [new_total]
    push.0.0.0
    padw mem_loadw_be.MEM_REFERRER
    push.REF_TOTAL_REVENUE_SLOT exec.native_account::set_map_item dropw dropw
    # []
    mem_load.MEM_PROTOCOL_FEE_AMT
    # [protocol_revenue]
end

# Input: [amt] Memory [PAYMENT_TOKEN]
# Output: []
proc._increase_total_revenue
    padw mem_loadw_be.MEM_PAYMENT_TOKEN
    push.TOTAL_REVENUE_SLOT exec.active_account::get_map_item drop drop drop
    # [total_amount, amt]
    add push.0.0.0
    # [FINAL_AMT]
    padw mem_loadw_be.MEM_PAYMENT_TOKEN
    # [PAYMENT_TOKEN, FINAL_AMT]
    push.TOTAL_REVENUE_SLOT exec.native_account::set_map_item dropw dropw
    # []
end

# Input: [] Memory [PAYMENT_TOKEN]
# Output: [claimable_revenue]
proc._get_remaining_revenue
    padw mem_loadw_be.MEM_PAYMENT_TOKEN
    push.TOTAL_REVENUE_SLOT exec.active_account::get_map_item drop drop drop
    # [total_revenue]
    padw mem_loadw_be.MEM_PAYMENT_TOKEN
    push.CLAIMED_REVENUE_SLOT exec.active_account::get_map_item drop drop drop
    # [claimed_revenue, total_revenue]
    u32assert2 u32overflowing_sub assertz.err=ERR_U32_OVERFLOW
    # [claimable_revenue]
end

# Input: [amt] Memory [PAYMENT_TOKEN]
# Output: [ASSET]
proc._get_asset
    push.0 swap
    padw mem_loadw_be.MEM_PAYMENT_TOKEN drop drop
    # [prefix, suffix, amt, 0]
end

# Input: [account_prefix, account_suffix] Memory [DOMAIN]
# Output: []
proc._update_domain_map
    push.0.0 dupw
    # [ACCOUNT, ACCOUNT]
    padw mem_loadw_be.MEM_DOMAIN
    push.DOMAIN_TO_ACCOUNT_ID_SLOT
    exec.native_account::set_map_item dropw dropw
    # [ACCOUNT]
    padw mem_loadw_be.MEM_DOMAIN swapw
    # [ACCOUNT, DOMAIN]
    push.ACCOUNT_ID_TO_DOMAIN_SLOT
    exec.native_account::set_map_item dropw dropw
    # []
end

# Input: [new_owner_prefix, new_owner_suffix] Memory [DOMAIN]
# Output: []
proc._update_domain_owner
    push.0.0
    # [0,0, prefix, suffix]
    padw mem_loadw_be.MEM_DOMAIN
    
    # [DOMAIN, 0, 0, prefix, suffix]
    push.DOMAIN_TO_OWNER_SLOT
    # [slot, DOMAIN, 0, 0, prefix, suffix]
    exec.native_account::set_map_item dropw dropw
    # []
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._assert_only_domain_owner
    padw mem_loadw_be.MEM_DOMAIN
    push.DOMAIN_TO_OWNER_SLOT
    # [slot, DOMAIN]
    exec.active_account::get_map_item drop drop
    # [owner_prefix, owner_suffix]
    push.0 exec.input_note::get_sender
    nop
    # [caller_prefix, caller_suffix, owner_prefix, owner_suffix]
    exec.account_id::is_equal assert.err=ERR_ONLY_DOMAIN_OWNER
    # []
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._assert_domain_not_expired
    padw mem_loadw_be.MEM_DOMAIN
    push.DOMAIN_EXPIRY_DATES exec.active_account::get_map_item drop drop drop
    # [current_len]
    exec.tx::get_block_timestamp
    # [ts, current_len]
    gt assert.err=ERR_DOMAIN_EXPIRED
    # []
end

# Input: [] Memory [DOMAIN, REG_LEN]
proc._update_domain_length
    padw mem_loadw_be.MEM_REG_LEN drop drop drop
    # [reg_len]
    dup lte.MAX_REG_LEN assert.err=ERR_DOMAIN_REGISTRATION_LENGTH_TOO_HIGH
    # [reg_len]
    exec._get_one_year
    u32overflowing_mul assertz.err=ERR_OVERFLOW_AT_DOMAIN_TIMESTAMP_LENGTH
    # [len * year]
    exec.tx::get_block_timestamp
    # [timestamp, len * yr]
    u32overflowing_add assertz.err=ERR_OVERFLOW_AT_DOMAIN_TIMESTAMP_LENGTH
    push.0.0.0
    # [END_TIME]
    padw mem_loadw_be.MEM_DOMAIN
    # [DOMAIN, END_TIME]
    push.DOMAIN_EXPIRY_DATES 
    exec.native_account::set_map_item dropw dropw
    # []
end

# Input: []
# Output: [one_year_time]
proc._get_one_year
    push.ONE_YEAR_TIMESTAMP_SLOT exec.active_account::get_item drop drop drop
end

# Input: []
# Output: []
proc._after_domain_register
    exec._increase_domain_count
end

# Input: []
# Output: []
proc._increase_domain_count
    push.DOMAIN_COUNT_SLOT
    exec.active_account::get_item drop drop drop
    # [total_supply]
    add.1 push.0.0.0
    # [0, 0, 0, total_supply + 1]
    push.DOMAIN_COUNT_SLOT exec.native_account::set_item dropw
end

# Input: [] Memory [DOMAIN, PAYMENT_TOKEN, REG_LEN]
# Output: [price]
# Call it after validate domain
proc._calculate_domain_price
    padw mem_loadw_be.MEM_PAYMENT_TOKEN drop drop
    # [prefix, suffix]
    padw mem_loadw_be.MEM_DOMAIN swap.3 drop drop drop
    # [length, prefix, suffix]
    push.0
    push.PRICES_SLOT exec.active_account::get_map_item drop drop drop
    # [price]
    exec._calculate_discount
    # [discounted_price]
    padw mem_loadw_be.MEM_REG_LEN drop drop drop
    # [reg_len, discounted_price]
    u32assert2 u32overflowing_mul assertz.err=ERR_CALCULATE_DISCOUNT_OVERFLOW

end

# Input: [price] Memory [REG_LEN]
# Output: [discounted_price]
proc._calculate_discount
    padw mem_loadw_be.MEM_REG_LEN drop drop drop
    # [reg_len, price]
    dup gte.5
    if.true
        # [reg_len, price]
        drop dup 
        # [price, price]
        push.FIVE_YR_DISCOUNT u32assert2 u32overflowing_mul
        assertz.err=ERR_CALCULATE_DISCOUNT_OVERFLOW
        u32assert2 u32div.10000
        u32assert2 u32overflowing_sub assertz.err=ERR_CALCULATE_DISCOUNT_UNDERFLOW
        # [discounted_price]
        
    else
        # [reg_len, price]
        gte.3
        if.true
            # [price]
            dup
            push.THREE_YR_DISCOUNT 
            u32assert2 u32overflowing_mul
            assertz.err=ERR_CALCULATE_DISCOUNT_OVERFLOW
            u32assert2 u32div.10000
            u32assert2 u32overflowing_sub assertz.err=ERR_CALCULATE_DISCOUNT_UNDERFLOW
            # [discounted price]
        else
            # [price]
            nop
        end
    end
end

# Input: [] Memory [PAYMENT_TOKEN]
# Output: [balance]
proc._get_balance
    padw mem_loadw_be.MEM_PAYMENT_TOKEN drop drop
    exec.active_account::get_balance
    # [balance]
end

# Input: [min_amt] Memory [PAYMENT_TOKEN]
# Output: []
proc._receive_payment
    exec._get_balance
    # [before_bal, min_amt]
    exec.active_note::add_assets_to_account
    exec._get_balance
    # [after_bal, before_bal, min_amt]
    swap u32overflowing_sub assertz.err=ERR_VALIDATE_PAYMENT_SUB_OVERFLOW
    lte assert.err=ERR_INSUFFICIENT_AMOUNT_PAID
    # []
end

# Input: [] Memory [PAYMENT_TOKEN]
# Output: []
proc._assert_payment_token
    padw mem_loadw_be.MEM_PAYMENT_TOKEN drop drop
    push.1
    # [letter, prefix, suffix]
    push.0
    # [PRICES_KEY]
    push.PRICES_SLOT
    exec.active_account::get_map_item drop drop drop
    # [price]
    gt.0 assert.err=ERR_PAYMENT_TOKEN_NOT_ALLOWED
    # []
end

# Input: []
# Output: []
proc._assert_only_owner
    push.0 exec.input_note::get_sender
    # [caller_prefix, caller_suffix]
    push.OWNER_SLOT
    exec.active_account::get_item
    # [0, 0, owner_prefix, owner_suffix, caller_prefix, caller_suffix]
    drop drop
    # [owner_prefix, owner_suffix, caller_prefix, caller_suffix]
    exec.account_id::is_equal assert.err=ERR_ONLY_OWNER
    # []
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._assert_domain_available
    padw mem_loadw_be.MEM_DOMAIN
    # First check is domain expired
    push.DOMAIN_EXPIRY_DATES
    exec.active_account::get_map_item 
    drop drop drop
    # [expiry_time]
    exec.tx::get_block_timestamp
    # [current_time, expiry_time]
    u32assert2 u32lt 
    
    if.false
        padw mem_loadw_be.MEM_DOMAIN
        push.DOMAIN_TO_OWNER_SLOT
        exec.active_account::get_map_item drop drop
        push.0.0 exec.account_id::is_equal

        assert.err=ERR_DOMAIN_NOT_AVAILABLE
    end
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._assert_domain_rules
    padw mem_loadw_be.MEM_DOMAIN
    dupw
    # [DOMAIN, DOMAIN]
    exec._validate_domain_length
    # [DOMAIN]
    lte.MAX_NAME_LENGTH
    # [len_check, f1, f2, f3]
    assert.err=ERR_DOMAIN_LENGTH_TOO_HIGH
    # [f1, f2, f3]
    drop drop drop
end

############################
## Domain length validations
############################

# Input: [] Memory [DOMAIN]
# Output: [length]
proc._get_domain_length
    padw mem_loadw_be.MEM_DOMAIN
    swap.3 drop drop drop
    # [length]
end

# Input: [length, felt1, felt2, felt3] -> DOMAIN
# Output: []
proc._validate_domain_length
    # Stack: [length, felt1, felt2, felt3]
    dup eq.0 assertz.err=ERR_EMPTY_DOMAIN
    dup lte.21 assert.err=ERR_DOMAIN_LENGTH_TOO_HIGH
    movdn.3
    # [f1, f2, f3, length]
    exec._count_chars_in_felt
    # [f1_count, f2, f3, length]
    movdn.2
    # [f2, f3, f1_count, length]
    exec._count_chars_in_felt swap
    # [f3, f2_count, f1_count, length]
    exec._count_chars_in_felt
    # [f3_count, f2_count, f1_count, length]
    add add 
    # [f3+f2+f1, length]
    eq
    # [1 or 0]
    assert.err=ERR_INVALID_DOMAIN_LENGTH
end

# Input: [felt]
# Output: [count]
proc._count_chars_in_felt
    u32split
    # [u32_high, u32_low]
    exec._count_chars_in_u32
    # [count_high, u32_low]
    swap
    exec._count_chars_in_u32
    # [count_low, count_high]
    add
    # [count]
end

# Input: [u32]
# Output: [count]
proc._count_chars_in_u32
    push.0 swap # push count
    # [u32, count]
    u32divmod.PAD_4TH_CHAR swap
    # [bolum, kalan, count]
    gt.0
    if.true
        # [kalan, count]
        swap 
        # [count, kalan]
        add.1 swap
        # [kalan, count + 1]
    end

    u32divmod.PAD_3RD_CHAR swap
    gt.0
    if.true
        # [kalan, count]
        swap 
        # [count, kalan]
        add.1 swap
        # [kalan, count + 1]
    end
    u32divmod.PAD_2ND_CHAR swap
    gt.0
    if.true
        swap add.1 swap
    end

    u32divmod.PAD_1ST_CHAR swap
    gt.0
    if.true
        swap add.1 swap
    end
    drop
end